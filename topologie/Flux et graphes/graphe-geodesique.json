{
  "geometry": {
    "topology": "geodesic_graph",
    "R": 1.0,
    "N": 2048,
    "geo_graph_level": 2,
    "seed": 0,
    "code": "import math\nimport random\nfrom core.topology_generators import BUILTIN_GENERATORS\n\ndef _as_tuples(points):\n    out = []\n    for pt in points:\n        if hasattr(pt, 'x'):\n            out.append((pt.x, pt.y, pt.z))\n        else:\n            out.append(tuple(pt[:3]))\n    return out\n\ndef generate_geodesic_graph_geometry(params, N):\n    radius = float(params.get('R', 1.0))\n    count = int(N or params.get('N') or 2048)\n    count = max(1, count)\n    raw_params = dict(params)\n    if 'geo_level' not in raw_params:\n        raw_params['geo_level'] = raw_params.get('geo_graph_level')\n    base_points = BUILTIN_GENERATORS['geodesic_sphere'](raw_params, count)\n    base = _as_tuples(base_points)\n    if not base:\n        return []\n    if len(base) >= count:\n        points = base[:count]\n    else:\n        rng = random.Random(params.get('seed', 0))\n        points = list(base)\n        while len(points) < count:\n            a, b = rng.sample(base, 2)\n            t = rng.random()\n            blend = (\n                (1.0 - t) * a[0] + t * b[0],\n                (1.0 - t) * a[1] + t * b[1],\n                (1.0 - t) * a[2] + t * b[2],\n            )\n            points.append(blend)\n        points = points[:count]\n    max_norm = max((math.sqrt(x * x + y * y + z * z) for x, y, z in points), default=1.0)\n    scale = radius / max_norm if max_norm else 1.0\n    return [(x * scale, y * scale, z * scale) for x, y, z in points]\n"
  },
  "meta": {
    "category": "Flux et graphes",
    "label": "Graphe géodésique",
    "description": "Échantillonnage aléatoire de sommets géodésiques sur une sphère.",
    "parameters": [
      "R",
      "N",
      "geo_graph_level",
      "seed"
    ]
  }
}
