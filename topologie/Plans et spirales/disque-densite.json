{
  "geometry": {
    "topology": "density_warp_disk",
    "R": 1.0,
    "N": 4096,
    "density_pdf": "1",
    "code": "from __future__ import annotations\n\nimport json\nimport math\nimport random\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Mapping, Sequence, Tuple\n\n__all__ = [\n    \"Point3D\",\n    \"BUILTIN_GENERATORS\",\n    \"_rand_for_index\",\n    \"_value_noise3\",\n    \"_scale\",\n    \"_unique_points\",\n    \"_PHI\",\n    \"_gen_uv_sphere\",\n]\n\n\n@dataclass\nclass Point3D:\n    \"\"\"Simple structure storing a 3D point and the seed used to generate it.\"\"\"\n\n    x: float\n    y: float\n    z: float\n    seed: int = 0\n\n    def copy(self) -> \"Point3D\":\n        return Point3D(self.x, self.y, self.z, self.seed)\n\ndef _parse_number_list(text: str | None) -> List[float]:\n    if not text:\n        return []\n    numbers: List[float] = []\n    for token in text.replace(\"\\n\", \" \").replace(\";\", \" \").split():\n        try:\n            value = float(token)\n        except (TypeError, ValueError):\n            continue\n        if math.isfinite(value):\n            numbers.append(value)\n    return numbers\n\ndef _parse_vector_list(text: str | None) -> List[Tuple[float, float, float]]:\n    if not text:\n        return []\n    tokens = [token.strip() for token in text.replace(\"\\r\", \"\").split(\";\")]\n    if not [token for token in tokens if token]:\n        flat = _parse_number_list(text)\n        if len(flat) >= 3:\n            return [(flat[0], flat[1], flat[2])]\n        return []\n    vectors: List[Tuple[float, float, float]] = []\n    for token in tokens:\n        if not token:\n            continue\n        parts = [p for p in token.replace(\",\", \" \").split() if p]\n        values: List[float] = []\n        for part in parts:\n            try:\n                values.append(float(part))\n            except (TypeError, ValueError):\n                continue\n        while len(values) < 3:\n            values.append(0.0)\n        if values:\n            vectors.append((values[0], values[1], values[2]))\n    return vectors\n\ndef _parse_bbox(text: str | None) -> Tuple[float, float, float, float]:\n    values = _parse_number_list(text)\n    if len(values) >= 4:\n        return (values[0], values[1], values[2], values[3])\n    return (-1.0, 1.0, -1.0, 1.0)\n\ndef _eval_expression(expr: str | None, variables: Mapping[str, float]) -> float:\n    if not expr or not expr.strip():\n        return 1.0\n    try:\n        code = compile(expr, \"<dyxten-expr>\", \"eval\")\n        return float(eval(code, {\"__builtins__\": {}}, {**math.__dict__, **variables}))\n    except Exception:\n        return 0.0\n\ndef _norm_scale(vector: Tuple[float, float, float], radius: float) -> Tuple[float, float, float]:\n    length = math.sqrt(vector[0] ** 2 + vector[1] ** 2 + vector[2] ** 2) or 1.0\n    return (\n        radius * vector[0] / length,\n        radius * vector[1] / length,\n        radius * vector[2] / length,\n    )\n\ndef _clamp_count(value: int, cap: int) -> int:\n    if cap and cap > 0:\n        return min(value, cap)\n    return value\n\ndef _normalize(vec: Tuple[float, float, float]) -> Tuple[float, float, float]:\n    length = math.sqrt(vec[0] ** 2 + vec[1] ** 2 + vec[2] ** 2) or 1.0\n    return (vec[0] / length, vec[1] / length, vec[2] / length)\n\ndef _scale(vec: Tuple[float, float, float], scale: float) -> Tuple[float, float, float]:\n    return (vec[0] * scale, vec[1] * scale, vec[2] * scale)\n\ndef _unique_points(vectors: Sequence[Tuple[float, float, float]], radius: float, cap: int) -> List[Point3D]:\n    out: List[Point3D] = []\n    seen = set()\n    for idx, vec in enumerate(vectors):\n        scaled = _norm_scale(vec, radius)\n        key = (round(scaled[0], 6), round(scaled[1], 6), round(scaled[2], 6))\n        if key in seen:\n            continue\n        seen.add(key)\n        out.append(Point3D(scaled[0], scaled[1], scaled[2], idx))\n        if cap and len(out) >= cap:\n            break\n    if cap:\n        return out[:cap]\n    return out\n\n_PHI = (1.0 + math.sqrt(5.0)) / 2.0\n\n\ndef _mix(a: Tuple[float, float, float], b: Tuple[float, float, float], t: float) -> Tuple[float, float, float]:\n    return (a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t, a[2] + (b[2] - a[2]) * t)\n\n\n_POLYHEDRA_DATA: Dict[str, Tuple[List[Tuple[float, float, float]], List[Tuple[int, ...]]]] = {\n    \"tetrahedron\": (\n        [\n            (1, 1, 1),\n            (1, -1, -1),\n            (-1, 1, -1),\n            (-1, -1, 1),\n        ],\n        [(0, 1, 2), (0, 3, 1), (0, 2, 3), (1, 3, 2)],\n    ),\n    \"cube\": (\n        [\n            (-1, -1, -1),\n            (1, -1, -1),\n            (1, 1, -1),\n            (-1, 1, -1),\n            (-1, -1, 1),\n            (1, -1, 1),\n            (1, 1, 1),\n            (-1, 1, 1),\n        ],\n        [\n            (0, 1, 2, 3),\n            (4, 5, 6, 7),\n            (0, 1, 5, 4),\n            (2, 3, 7, 6),\n            (1, 2, 6, 5),\n            (3, 0, 4, 7),\n        ],\n    ),\n    \"octahedron\": (\n        [\n            (1, 0, 0),\n            (-1, 0, 0),\n            (0, 1, 0),\n            (0, -1, 0),\n            (0, 0, 1),\n            (0, 0, -1),\n        ],\n        [(0, 2, 4), (2, 1, 4), (1, 3, 4), (3, 0, 4), (2, 0, 5), (1, 2, 5), (3, 1, 5), (0, 3, 5)],\n    ),\n    \"icosahedron\": (\n        [\n            (-1, _PHI, 0),\n            (1, _PHI, 0),\n            (-1, -_PHI, 0),\n            (1, -_PHI, 0),\n            (0, -1, _PHI),\n            (0, 1, _PHI),\n            (0, -1, -_PHI),\n            (0, 1, -_PHI),\n            (_PHI, 0, -1),\n            (_PHI, 0, 1),\n            (-_PHI, 0, -1),\n            (-_PHI, 0, 1),\n        ],\n        [\n            (0, 11, 5),\n            (0, 5, 1),\n            (0, 1, 7),\n            (0, 7, 10),\n            (0, 10, 11),\n            (1, 5, 9),\n            (5, 11, 4),\n            (11, 10, 2),\n            (10, 7, 6),\n            (7, 1, 8),\n            (3, 9, 4),\n            (3, 4, 2),\n            (3, 2, 6),\n            (3, 6, 8),\n            (3, 8, 9),\n            (4, 9, 5),\n            (2, 4, 11),\n            (6, 2, 10),\n            (8, 6, 7),\n            (9, 8, 1),\n        ],\n    ),\n    \"dodecahedron\": (\n        [\n            (-1, -1, -1),\n            (-1, -1, 1),\n            (-1, 1, -1),\n            (-1, 1, 1),\n            (1, -1, -1),\n            (1, -1, 1),\n            (1, 1, -1),\n            (1, 1, 1),\n            (0, -1 / _PHI, -_PHI),\n            (0, -1 / _PHI, _PHI),\n            (0, 1 / _PHI, -_PHI),\n            (0, 1 / _PHI, _PHI),\n            (-1 / _PHI, -_PHI, 0),\n            (-1 / _PHI, _PHI, 0),\n            (1 / _PHI, -_PHI, 0),\n            (1 / _PHI, _PHI, 0),\n            (-_PHI, 0, -1 / _PHI),\n            (_PHI, 0, -1 / _PHI),\n            (-_PHI, 0, 1 / _PHI),\n            (_PHI, 0, 1 / _PHI),\n        ],\n        [\n            (0, 8, 10, 2, 16),\n            (0, 12, 14, 4, 8),\n            (0, 16, 18, 1, 12),\n            (1, 9, 11, 3, 13),\n            (1, 18, 19, 5, 9),\n            (2, 10, 6, 17, 16),\n            (2, 3, 11, 7, 6),\n            (3, 13, 15, 7, 11),\n            (4, 14, 15, 7, 6),\n            (4, 5, 19, 17, 8),\n            (5, 9, 11, 7, 15),\n            (6, 7, 15, 14, 10),\n        ],\n    ),\n}\n\n\ndef _polyhedron_points(\n    base_vertices: Sequence[Tuple[float, float, float]],\n    faces: Sequence[Tuple[int, ...]],\n    radius: float,\n    layers: int,\n    link_steps: int,\n    cap: int,\n) -> List[Point3D]:\n    if not base_vertices:\n        return []\n    vectors: List[Tuple[float, float, float]] = list(base_vertices)\n    layers = max(1, layers)\n    if layers > 1:\n        for layer in range(1, layers):\n            scale = layer / layers\n            for v in base_vertices:\n                vectors.append(_scale(v, scale))\n    if link_steps > 0 and faces:\n        edges = set()\n        for face in faces:\n            if len(face) < 2:\n                continue\n            for i in range(len(face)):\n                a = face[i]\n                b = face[(i + 1) % len(face)]\n                edges.add(tuple(sorted((a, b))))\n        for a, b in edges:\n            try:\n                va = base_vertices[a]\n                vb = base_vertices[b]\n            except IndexError:\n                continue\n            for step in range(1, link_steps + 1):\n                t = step / (link_steps + 1)\n                vectors.append(_mix(va, vb, t))\n    points: List[Point3D] = []\n    seen = set()\n    for idx, vec in enumerate(vectors):\n        sx = radius * float(vec[0])\n        sy = radius * float(vec[1])\n        sz = radius * float(vec[2])\n        key = (round(sx, 6), round(sy, 6), round(sz, 6))\n        if key in seen:\n            continue\n        seen.add(key)\n        points.append(Point3D(sx, sy, sz, idx))\n        if cap and len(points) >= cap:\n            break\n    if cap:\n        return points[:cap]\n    return points\n\n\ndef _parse_polyhedron_json(text: str | None) -> Tuple[List[Tuple[float, float, float]], List[Tuple[int, ...]]]:\n    if not text:\n        return ([], [])\n    try:\n        payload = json.loads(text)\n    except Exception:\n        return ([], [])\n    vertices_raw = payload.get(\"vertices\") if isinstance(payload, dict) else None\n    faces_raw = payload.get(\"faces\") if isinstance(payload, dict) else None\n    vertices: List[Tuple[float, float, float]] = []\n    faces: List[Tuple[int, ...]] = []\n    if isinstance(vertices_raw, list):\n        for entry in vertices_raw:\n            if isinstance(entry, (list, tuple)) and len(entry) >= 3:\n                try:\n                    vertices.append((float(entry[0]), float(entry[1]), float(entry[2])))\n                except (TypeError, ValueError):\n                    continue\n    if isinstance(faces_raw, list):\n        for face in faces_raw:\n            if isinstance(face, (list, tuple)) and len(face) >= 3:\n                clean: List[int] = []\n                for idx in face:\n                    try:\n                        clean.append(int(idx))\n                    except (TypeError, ValueError):\n                        continue\n                if len(clean) >= 3:\n                    faces.append(tuple(clean))\n    return vertices, faces\n\ndef _polyhedron_vectors(name: str) -> Tuple[List[Tuple[float, float, float]], List[Tuple[int, ...]]]:\n    data = _POLYHEDRA_DATA.get(name)\n    if data:\n        return data\n    return ([], [])\n\ndef _subdivide_geodesic(level: int) -> Tuple[List[Tuple[float, float, float]], List[Tuple[int, int, int]]]:\n    vertices, faces = _POLYHEDRA_DATA[\"icosahedron\"]\n    verts = [tuple(_normalize(v)) for v in vertices]\n    tris = [tuple(face[:3]) for face in faces]\n\n    def midpoint(a_idx: int, b_idx: int, cache: Dict[Tuple[int, int], int]) -> int:\n        key = tuple(sorted((a_idx, b_idx)))\n        cached = cache.get(key)\n        if cached is not None:\n            return cached\n        va = verts[a_idx]\n        vb = verts[b_idx]\n        mid = _normalize(((va[0] + vb[0]) * 0.5, (va[1] + vb[1]) * 0.5, (va[2] + vb[2]) * 0.5))\n        verts.append(mid)\n        index = len(verts) - 1\n        cache[key] = index\n        return index\n\n    for _ in range(max(0, level)):\n        cache: Dict[Tuple[int, int], int] = {}\n        new_tris: List[Tuple[int, int, int]] = []\n        for a, b, c in tris:\n            ab = midpoint(a, b, cache)\n            bc = midpoint(b, c, cache)\n            ca = midpoint(c, a, cache)\n            new_tris.extend(\n                [\n                    (a, ab, ca),\n                    (b, bc, ab),\n                    (c, ca, bc),\n                    (ab, bc, ca),\n                ]\n            )\n        tris = new_tris\n    return verts, tris\n\ndef _parse_spherical_terms(text: str | None) -> List[Tuple[int, int, float]]:\n    if not text:\n        return []\n    terms: List[Tuple[int, int, float]] = []\n    for token in text.replace(\"\\r\", \"\").split(\";\"):\n        if not token.strip():\n            continue\n        parts = token.replace(\",\", \" \").split()\n        if len(parts) < 3:\n            continue\n        try:\n            l = int(float(parts[0]))\n            m = int(float(parts[1]))\n            amp = float(parts[2])\n        except (TypeError, ValueError):\n            continue\n        terms.append((max(0, l), m, amp))\n    return terms\n\ndef _associated_legendre(l: int, m: int, x: float) -> float:\n    m_abs = abs(m)\n    pmm = 1.0\n    if m_abs > 0:\n        somx2 = math.sqrt(max(0.0, 1.0 - x * x))\n        fact = 1.0\n        for i in range(1, m_abs + 1):\n            pmm *= -fact * somx2\n            fact += 2.0\n    if l == m_abs:\n        return pmm\n    pmmp1 = x * (2 * m_abs + 1) * pmm\n    if l == m_abs + 1:\n        return pmmp1\n    pll = 0.0\n    for n in range(m_abs + 2, l + 1):\n        pll = ((2 * n - 1) * x * pmmp1 - (n + m_abs - 1) * pmm) / (n - m_abs)\n        pmm, pmmp1 = pmmp1, pll\n    return pll\n\ndef _real_spherical_harmonic(l: int, m: int, theta: float, phi: float) -> float:\n    m_abs = abs(m)\n    norm = math.sqrt(\n        ((2 * l + 1) / (4 * math.pi))\n        * (math.factorial(l - m_abs) / max(1, math.factorial(l + m_abs)))\n    )\n    p_lm = _associated_legendre(l, m_abs, math.cos(theta))\n    if m == 0:\n        return norm * p_lm\n    factor = math.sqrt(2.0) * norm\n    if m > 0:\n        return factor * p_lm * math.cos(m * phi)\n    return factor * p_lm * math.sin(m_abs * phi)\n\ndef _rand_for_index(index: int, salt: int = 0) -> float:\n    s = index * 12.9898 + salt * 78.233\n    x = math.sin(s) * 43758.5453\n    return x - math.floor(x)\n\ndef _value_noise3(x: float, y: float, z: float) -> float:\n    xi = math.floor(x)\n    yi = math.floor(y)\n    zi = math.floor(z)\n    xf = x - xi\n    yf = y - yi\n    zf = z - zi\n\n    def _hash(ix: int, iy: int, iz: int) -> float:\n        n = ix * 15731 + iy * 789221 + iz * 1376312589\n        n = (n << 13) ^ n\n        return (1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7FFFFFFF) / 1073741824.0) * 0.5 + 0.5\n\n    def _lerp(a: float, b: float, t: float) -> float:\n        return a + (b - a) * t\n\n    def _smooth(t: float) -> float:\n        return t * t * (3.0 - 2.0 * t)\n\n    c000 = _hash(xi, yi, zi)\n    c100 = _hash(xi + 1, yi, zi)\n    c010 = _hash(xi, yi + 1, zi)\n    c110 = _hash(xi + 1, yi + 1, zi)\n    c001 = _hash(xi, yi, zi + 1)\n    c101 = _hash(xi + 1, yi, zi + 1)\n    c011 = _hash(xi, yi + 1, zi + 1)\n    c111 = _hash(xi + 1, yi + 1, zi + 1)\n\n    u = _smooth(xf)\n    v = _smooth(yf)\n    w = _smooth(zf)\n\n    x00 = _lerp(c000, c100, u)\n    x10 = _lerp(c010, c110, u)\n    x01 = _lerp(c001, c101, u)\n    x11 = _lerp(c011, c111, u)\n    y0 = _lerp(x00, x10, v)\n    y1 = _lerp(x01, x11, v)\n    return _lerp(y0, y1, w)\n\ndef _gen_uv_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    points: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / (lat_steps - 1 if lat_steps > 1 else 1)\n        theta = v * math.pi\n        sin_theta = math.sin(theta)\n        cos_theta = math.cos(theta)\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi\n            cos_phi = math.cos(phi)\n            sin_phi = math.sin(phi)\n            points.append(\n                Point3D(\n                    radius * sin_theta * cos_phi,\n                    radius * cos_theta,\n                    radius * sin_theta * sin_phi,\n                )\n            )\n    return points[:_clamp_count(len(points), cap)]\n\ndef _gen_fibo_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    phi_g = float(geo.get(\"phi_g\", 0.0) or 0.0)\n    denom = max(1, count - 1)\n    out: List[Point3D] = []\n    for i in range(count):\n        z = 1 - (2 * i) / denom\n        r = math.sqrt(max(0.0, 1 - z * z))\n        phi = i * phi_g\n        out.append(\n            Point3D(\n                radius * r * math.cos(phi),\n                radius * z,\n                radius * r * math.sin(phi),\n            )\n        )\n    return out\n\ndef _gen_vogel_sphere_spiral(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    k = float(geo.get(\"vogel_k\", 2.3999632) or 2.3999632)\n    out: List[Point3D] = []\n    for i in range(count):\n        t = (i + 0.5) / count\n        theta = math.acos(1.0 - 2.0 * t)\n        phi = (i * k) % (2.0 * math.pi)\n        sin_theta = math.sin(theta)\n        out.append(\n            Point3D(\n                radius * sin_theta * math.cos(phi),\n                radius * math.cos(theta),\n                radius * sin_theta * math.sin(phi),\n            )\n        )\n    return out\n\ndef _superquadric_coord(angle: float, exponent: float) -> float:\n    exponent = max(1e-3, exponent)\n    return math.copysign(abs(math.cos(angle)) ** (2.0 / exponent), math.cos(angle))\n\ndef _superquadric_sine(angle: float, exponent: float) -> float:\n    exponent = max(1e-3, exponent)\n    return math.copysign(abs(math.sin(angle)) ** (2.0 / exponent), math.sin(angle))\n\ndef _gen_superquadric(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    eps1 = float(geo.get(\"eps1\", 1.0) or 1.0)\n    eps2 = float(geo.get(\"eps2\", 1.0) or 1.0)\n    ax = float(geo.get(\"ax\", 1.0) or 1.0)\n    ay = float(geo.get(\"ay\", 1.0) or 1.0)\n    az = float(geo.get(\"az\", 1.0) or 1.0)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = -0.5 * math.pi + (math.pi * i) / max(1, lat_steps - 1)\n        cv = _superquadric_coord(v, eps1)\n        sv = _superquadric_sine(v, eps1)\n        for j in range(lon_steps):\n            u = -math.pi + (2.0 * math.pi * j) / lon_steps\n            cu = _superquadric_coord(u, eps2)\n            su = _superquadric_sine(u, eps2)\n            out.append(\n                Point3D(\n                    radius * ax * cv * cu,\n                    radius * ay * cv * su,\n                    radius * az * sv,\n                )\n            )\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_superellipsoid(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    ax = float(geo.get(\"ax\", 1.0) or 1.0)\n    ay = float(geo.get(\"ay\", 1.0) or 1.0)\n    az = float(geo.get(\"az\", 1.0) or 1.0)\n    n1 = float(geo.get(\"se_n1\", 1.0) or 1.0)\n    n2 = float(geo.get(\"se_n2\", 1.0) or 1.0)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = -0.5 * math.pi + (math.pi * i) / max(1, lat_steps - 1)\n        cv = math.cos(v)\n        sv = math.sin(v)\n        for j in range(lon_steps):\n            u = -math.pi + (2.0 * math.pi * j) / lon_steps\n            cu = math.cos(u)\n            su = math.sin(u)\n            x = radius * ax * math.copysign(abs(cv) ** (2.0 / max(1e-3, n1)), cv) * math.copysign(abs(cu) ** (2.0 / max(1e-3, n2)), cu)\n            y = radius * ay * math.copysign(abs(cv) ** (2.0 / max(1e-3, n1)), cv) * math.copysign(abs(su) ** (2.0 / max(1e-3, n2)), su)\n            z = radius * az * math.copysign(abs(sv) ** (2.0 / max(1e-3, n1)), sv)\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_half_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    height = float(geo.get(\"half_height\", 1.0) or 1.0)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = (i / max(1, lat_steps - 1)) * 0.5 * math.pi\n        sin_theta = math.sin(v)\n        cos_theta = math.cos(v)\n        for j in range(lon_steps):\n            phi = (j / lon_steps) * 2.0 * math.pi\n            out.append(\n                Point3D(\n                    radius * sin_theta * math.cos(phi),\n                    radius * cos_theta * height,\n                    radius * sin_theta * math.sin(phi),\n                )\n            )\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_noisy_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    amp = float(geo.get(\"noisy_amp\", 0.1) or 0.0)\n    freq = float(geo.get(\"noisy_freq\", 1.0) or 1.0)\n    gain = float(geo.get(\"noisy_gain\", 1.0) or 1.0)\n    omega = float(geo.get(\"noisy_omega\", 0.0) or 0.0)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / (lat_steps - 1 if lat_steps > 1 else 1)\n        theta = v * math.pi\n        sin_theta = math.sin(theta)\n        cos_theta = math.cos(theta)\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi\n            nx = sin_theta * math.cos(phi)\n            ny = cos_theta\n            nz = sin_theta * math.sin(phi)\n            n = 0.0\n            frequency = freq\n            amplitude = 1.0\n            for _ in range(3):\n                sample = _value_noise3(nx * frequency + omega, ny * frequency, nz * frequency - omega)\n                n += sample * amplitude\n                amplitude *= gain\n                frequency *= 2.0\n            offset = 1.0 + amp * (n - 0.5)\n            out.append(Point3D(radius * nx * offset, radius * ny * offset, radius * nz * offset))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_spherical_harmonics(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    terms = _parse_spherical_terms(geo.get(\"sph_terms\"))\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / (lat_steps - 1 if lat_steps > 1 else 1)\n        theta = v * math.pi\n        sin_theta = math.sin(theta)\n        cos_theta = math.cos(theta)\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi\n            amp = 0.0\n            for l, m, coeff in terms:\n                amp += coeff * _real_spherical_harmonic(l, m, theta, phi)\n            amp = 1.0 + amp\n            amp = max(0.1, amp)\n            out.append(\n                Point3D(\n                    radius * amp * sin_theta * math.cos(phi),\n                    radius * amp * cos_theta,\n                    radius * amp * sin_theta * math.sin(phi),\n                )\n            )\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_weighted_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    weight_expr = geo.get(\"weight_map\")\n    out: List[Point3D] = []\n    for i in range(count):\n        u = (i + 0.5) / count\n        theta = math.acos(1 - 2 * u)\n        phi = (i * 2.3999632) % (2 * math.pi)\n        weight = _eval_expression(weight_expr, {\"theta\": theta, \"phi\": phi})\n        weight = max(0.05, float(weight) if weight else 1.0)\n        sin_theta = math.sin(theta)\n        out.append(\n            Point3D(\n                radius * weight * sin_theta * math.cos(phi),\n                radius * weight * math.cos(theta),\n                radius * weight * sin_theta * math.sin(phi),\n            )\n        )\n    return out\n\ndef _gen_disk_phyllo(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    phi_g = float(geo.get(\"phi_g\", 0.0) or 0.0)\n    out: List[Point3D] = []\n    denom = max(1, count - 1)\n    for k in range(count):\n        theta = k * phi_g\n        r = radius * math.sqrt(k / denom)\n        out.append(Point3D(r * math.cos(theta), 0.0, r * math.sin(theta)))\n    return out\n\ndef _gen_archimede_spiral(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    theta_max = max(0.1, float(geo.get(\"theta_max\", 0.0) or (math.pi * 6)))\n    arch_a = float(geo.get(\"arch_a\", 0.0) or 0.0)\n    arch_b = float(geo.get(\"arch_b\", 0.0) or 0.0)\n    radius = float(geo.get(\"R\", 1.0))\n    denom = arch_a + arch_b * theta_max\n    scale = radius / abs(denom) if denom != 0 else radius\n    out: List[Point3D] = []\n    for i in range(count):\n        t = 0.0 if count == 1 else theta_max * i / (count - 1)\n        r = abs(arch_a + arch_b * t) * scale\n        out.append(Point3D(r * math.cos(t), 0.0, r * math.sin(t)))\n    return out\n\ndef _gen_log_spiral(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    theta_max = max(0.1, float(geo.get(\"theta_max\", 0.0) or (math.pi * 6)))\n    log_a = float(geo.get(\"log_a\", 0.0) or 0.0)\n    log_b = float(geo.get(\"log_b\", 0.0) or 0.0)\n    radius = float(geo.get(\"R\", 1.0))\n    base = math.exp(log_b * theta_max)\n    scale = radius / (log_a * base) if log_a * base != 0 else radius\n    out: List[Point3D] = []\n    for i in range(count):\n        t = 0.0 if count == 1 else theta_max * i / (count - 1)\n        r = abs(log_a * math.exp(log_b * t)) * scale\n        out.append(Point3D(r * math.cos(t), 0.0, r * math.sin(t)))\n    return out\n\ndef _gen_rose_curve(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    theta_max = max(0.1, float(geo.get(\"theta_max\", 0.0) or (2 * math.pi)))\n    rose_k = float(geo.get(\"rose_k\", 0.0) or 0.0)\n    radius = float(geo.get(\"R\", 1.0))\n    out: List[Point3D] = []\n    for i in range(count):\n        t = 0.0 if count == 1 else theta_max * i / (count - 1)\n        r = abs(math.cos(rose_k * t)) * radius\n        out.append(Point3D(r * math.cos(t), 0.0, r * math.sin(t)))\n    return out\n\ndef _superformula2d(theta: float, m: float, a: float, b: float, n1: float, n2: float, n3: float) -> float:\n    part1 = abs(math.cos((m * theta) / 4.0) / (a or 1.0)) ** n2\n    part2 = abs(math.sin((m * theta) / 4.0) / (b or 1.0)) ** n3\n    return (part1 + part2) ** (-1.0 / max(1e-6, n1))\n\ndef _gen_superformula_2d(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    m = float(geo.get(\"sf2_m\", 0.0) or 0.0)\n    a = float(geo.get(\"sf2_a\", 0.0) or 1.0)\n    b = float(geo.get(\"sf2_b\", 0.0) or 1.0)\n    n1 = float(geo.get(\"sf2_n1\", 0.0) or 0.5)\n    n2 = float(geo.get(\"sf2_n2\", 0.0) or 0.5)\n    n3 = float(geo.get(\"sf2_n3\", 0.0) or 0.5)\n    out: List[Point3D] = []\n    for i in range(count):\n        theta = (i / count) * 2.0 * math.pi\n        r = radius * _superformula2d(theta, m, a, b, n1, n2, n3)\n        out.append(Point3D(r * math.cos(theta), 0.0, r * math.sin(theta)))\n    return out\n\ndef _gen_density_warp(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    density_expr = geo.get(\"density_pdf\")\n    out: List[Point3D] = []\n    attempts = 0\n    max_attempts = count * 20\n    while len(out) < count and attempts < max_attempts:\n        attempts += 1\n        u = random.random()\n        r = math.sqrt(u)\n        pdf = max(0.0, _eval_expression(density_expr, {\"r\": r, \"u\": u}))\n        if pdf <= 0:\n            continue\n        if random.random() > clamp01(pdf):\n            continue\n        theta = random.random() * 2.0 * math.pi\n        radius_abs = radius * r\n        out.append(Point3D(radius_abs * math.cos(theta), 0.0, radius_abs * math.sin(theta)))\n    return out\n\ndef _gen_poisson_disk(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    min_dist = max(0.0, float(geo.get(\"poisson_dmin\", 0.0) or 0.0)) * radius\n    out: List[Point3D] = []\n    tries = 0\n    max_tries = count * 50\n    while len(out) < count and tries < max_tries:\n        tries += 1\n        r = radius * math.sqrt(random.random())\n        theta = random.random() * 2.0 * math.pi\n        point = Point3D(r * math.cos(theta), 0.0, r * math.sin(theta))\n        ok = True\n        for existing in out:\n            dx = point.x - existing.x\n            dz = point.z - existing.z\n            if dx * dx + dz * dz < min_dist * min_dist:\n                ok = False\n                break\n        if ok:\n            out.append(point)\n    return out\n\ndef _gen_lissajous_disk(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    a = max(1, int(geo.get(\"lissajous_a\", 0) or 0))\n    b = max(1, int(geo.get(\"lissajous_b\", 0) or 0))\n    phase = float(geo.get(\"lissajous_phase\", 0.0) or 0.0)\n    out: List[Point3D] = []\n    for i in range(count):\n        t = (i / count) * 2.0 * math.pi\n        x = math.cos(a * t + phase)\n        z = math.sin(b * t)\n        out.append(Point3D(radius * x, 0.0, radius * z))\n    return out\n\ndef _gen_torus(geo: Mapping[str, float], cap: int, scale_radius: float = 1.0) -> List[Point3D]:\n    Rmaj = float(geo.get(\"R_major\", 0.0) or 1.2)\n    rmin = float(geo.get(\"r_minor\", 0.0) or 0.45)\n    lat_steps = max(3, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    radius = float(geo.get(\"R\", 1.0)) * scale_radius\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / lat_steps\n        theta = v * 2.0 * math.pi\n        cos_theta = math.cos(theta)\n        sin_theta = math.sin(theta)\n        ring = Rmaj + rmin * cos_theta\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi\n            cos_phi = math.cos(phi)\n            sin_phi = math.sin(phi)\n            out.append(\n                Point3D(\n                    radius * ring * cos_phi,\n                    radius * (rmin * sin_theta),\n                    radius * ring * sin_phi,\n                )\n            )\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_double_torus(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    primary = _gen_torus(geo, cap)\n    secondary_geo = dict(geo)\n    secondary_geo[\"R_major\"] = float(geo.get(\"R_major2\", geo.get(\"R_major\", 1.2)))\n    secondary = _gen_torus(secondary_geo, cap)\n    combined = primary + secondary\n    return combined[:_clamp_count(len(combined), cap)]\n\ndef _gen_horn_torus(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    horn_geo = dict(geo)\n    r_minor = float(geo.get(\"r_minor\", 0.45) or 0.45)\n    horn_geo[\"r_minor\"] = r_minor\n    R_major = float(geo.get(\"R_major\", 0.0) or r_minor)\n    if not math.isfinite(R_major):\n        R_major = r_minor\n    # Clamp the major radius so it cannot grow beyond the minor radius.\n    if R_major > r_minor:\n        R_major = r_minor\n    horn_geo[\"R_major\"] = R_major\n    return _gen_torus(horn_geo, cap)\n\ndef _gen_spindle_torus(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    spindle_geo = dict(geo)\n    r_minor = float(geo.get(\"r_minor\", 0.45) or 0.45)\n    spindle_geo[\"r_minor\"] = r_minor\n    R_major = float(geo.get(\"R_major\", 0.0) or (0.75 * r_minor))\n    if not math.isfinite(R_major):\n        R_major = 0.75 * r_minor\n    # Clamp the major radius below the minor radius to keep the spindle self-intersection.\n    if R_major >= r_minor:\n        R_major = max(0.25 * r_minor, r_minor * 0.75)\n    spindle_geo[\"R_major\"] = R_major\n    return _gen_torus(spindle_geo, cap)\n\ndef _gen_torus_knot(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(50, int(geo.get(\"N\", 0) or 0)), cap)\n    p = max(1, int(geo.get(\"torus_knot_p\", 0) or 0))\n    q = max(1, int(geo.get(\"torus_knot_q\", 0) or 0))\n    R_major = float(geo.get(\"R_major\", 1.0) or 1.0)\n    r_minor = float(geo.get(\"r_minor\", 0.2) or 0.2)\n    radius = float(geo.get(\"R\", 1.0))\n    total = 2.0 * math.pi * p\n    out: List[Point3D] = []\n    for i in range(count):\n        t = total * i / count\n        cos_q = math.cos(q * t / p)\n        sin_q = math.sin(q * t / p)\n        x = (R_major + r_minor * cos_q) * math.cos(t)\n        y = (R_major + r_minor * cos_q) * math.sin(t)\n        z = r_minor * sin_q\n        out.append(Point3D(x * radius, y * radius, z * radius))\n    return out\n\ndef _gen_strip_twist(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    lat_steps = max(3, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(20, int(geo.get(\"lon\", 0) or 0))\n    half_w = float(geo.get(\"strip_w\", 0.0) or 0.0) / 2.0\n    twist_n = float(geo.get(\"strip_n\", 0.0) or 0.0)\n    radius = float(geo.get(\"R\", 1.0))\n    out: List[Point3D] = []\n    for i in range(lon_steps):\n        u = i / lon_steps * 2.0 * math.pi\n        for j in range(lat_steps):\n            v = -half_w + (j / (lat_steps - 1 if lat_steps > 1 else 1)) * (2 * half_w)\n            angle = twist_n * u / 2.0\n            x = (radius + v * math.cos(angle)) * math.cos(u)\n            y = v * math.sin(angle)\n            z = (radius + v * math.cos(angle)) * math.sin(u)\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_klein_bottle(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    lat_steps = max(3, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    R_major = float(geo.get(\"R_major\", 0.0) or 0.0)\n    r_minor = float(geo.get(\"r_minor\", 0.0) or 0.0)\n    out: List[Point3D] = []\n    for i in range(lon_steps):\n        v = i / lon_steps * 2.0 * math.pi\n        sin_v = math.sin(v)\n        sin_2v = math.sin(2 * v)\n        for j in range(lat_steps):\n            u = j / lat_steps * 2.0 * math.pi\n            cos_u = math.cos(u)\n            sin_u = math.sin(u)\n            cos_u_half = math.cos(u / 2.0)\n            sin_u_half = math.sin(u / 2.0)\n            x = (R_major + r_minor * cos_u_half * sin_v - r_minor * sin_u_half * sin_2v) * cos_u\n            y = (R_major + r_minor * cos_u_half * sin_v - r_minor * sin_u_half * sin_2v) * sin_u\n            z = r_minor * sin_u_half * sin_v + r_minor * cos_u_half * sin_2v\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_mobius(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(3, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    width = float(geo.get(\"mobius_w\", 0.4) or 0.4)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        u = (i / lat_steps) * 2.0 * math.pi\n        cos_u = math.cos(u)\n        sin_u = math.sin(u)\n        cos_half = math.cos(u / 2.0)\n        sin_half = math.sin(u / 2.0)\n        for j in range(lon_steps):\n            v = (j / max(1, lon_steps - 1)) * 2.0 - 1.0\n            s = v * width * 0.5\n            x = (radius + s * cos_half) * cos_u\n            y = (radius + s * cos_half) * sin_u\n            z = s * sin_half\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_concentric_rings(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    rings = max(1, int(geo.get(\"rings_count\", 0) or 0))\n    per_ring = max(3, int(geo.get(\"ring_points\", 0) or 0))\n    out: List[Point3D] = []\n    if rings <= 1:\n        out.append(Point3D(0.0, 0.0, 0.0))\n    for ring in range(rings):\n        r = radius * (ring / max(1, rings - 1)) if rings > 1 else 0.0\n        for j in range(per_ring):\n            angle = (j / per_ring) * 2.0 * math.pi\n            out.append(Point3D(r * math.cos(angle), 0.0, r * math.sin(angle)))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_hex_packing_plane(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    step = float(geo.get(\"hex_step\", 0.2) or 0.2)\n    nx = max(1, int(geo.get(\"hex_nx\", 1) or 1))\n    ny = max(1, int(geo.get(\"hex_ny\", 1) or 1))\n    points: List[Tuple[float, float]] = []\n    for ix in range(nx):\n        for iy in range(ny):\n            x = (ix - (nx - 1) / 2.0) * step\n            z = (iy - (ny - 1) / 2.0) * step * math.sqrt(3) / 2.0\n            if ix % 2:\n                z += step * math.sqrt(3) / 4.0\n            points.append((x, z))\n    max_len = max((math.hypot(x, z) for x, z in points), default=1.0) or 1.0\n    scale = radius / max_len if max_len else 1.0\n    out = [Point3D(x * scale, 0.0, z * scale) for x, z in points]\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_voronoi_seeds(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    count = _clamp_count(max(1, int(geo.get(\"voronoi_N\", 0) or 0)), cap)\n    xmin, xmax, ymin, ymax = _parse_bbox(geo.get(\"voronoi_bbox\"))\n    out: List[Point3D] = []\n    for _ in range(count):\n        x = random.uniform(xmin, xmax) * radius\n        z = random.uniform(ymin, ymax) * radius\n        out.append(Point3D(x, 0.0, z))\n    return out\n\ndef _gen_helix(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    r = float(geo.get(\"helix_r\", 0.4) or 0.4) * radius\n    pitch = float(geo.get(\"helix_pitch\", 0.3) or 0.3) * radius\n    turns = max(0.1, float(geo.get(\"helix_turns\", 1.0) or 1.0))\n    height = pitch * turns\n    out: List[Point3D] = []\n    for i in range(count):\n        t = turns * 2.0 * math.pi * (i / max(1, count - 1))\n        x = r * math.cos(t)\n        z = r * math.sin(t)\n        y = -height / 2.0 + (pitch * t) / (2.0 * math.pi)\n        out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_viviani_curve(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    a = float(geo.get(\"viviani_a\", 1.0) or 1.0)\n    radius = float(geo.get(\"R\", 1.0))\n    out: List[Point3D] = []\n    for i in range(count):\n        t = 2.0 * math.pi * (i / max(1, count - 1))\n        x = a * (1 + math.cos(t))\n        y = a * math.sin(t)\n        z = 2 * a * math.sin(t / 2.0)\n        out.append(Point3D((x - 1.5 * a) * radius, y * radius, z * radius))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_lissajous3d(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(2, int(geo.get(\"N\", 0) or 0)), cap)\n    Ax = float(geo.get(\"lissajous3d_Ax\", 1.0) or 1.0)\n    Ay = float(geo.get(\"lissajous3d_Ay\", 1.0) or 1.0)\n    Az = float(geo.get(\"lissajous3d_Az\", 1.0) or 1.0)\n    wx = max(1, int(geo.get(\"lissajous3d_wx\", 1) or 1))\n    wy = max(1, int(geo.get(\"lissajous3d_wy\", 1) or 1))\n    wz = max(1, int(geo.get(\"lissajous3d_wz\", 1) or 1))\n    phi = float(geo.get(\"lissajous3d_phi\", 0.0) or 0.0)\n    radius = float(geo.get(\"R\", 1.0))\n    out: List[Point3D] = []\n    for i in range(count):\n        t = 2.0 * math.pi * i / count\n        x = Ax * math.sin(wx * t + phi)\n        y = Ay * math.sin(wy * t)\n        z = Az * math.sin(wz * t + phi / 2.0)\n        out.append(Point3D(x * radius, y * radius, z * radius))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_line_integral_convolution_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    line_count = max(1, int(geo.get(\"lic_N\", 1) or 1))\n    steps = max(4, int(geo.get(\"lic_steps\", 0) or 0))\n    out: List[Point3D] = []\n    for _ in range(line_count):\n        # Random great circle\n        theta = random.random() * math.pi\n        phi = random.random() * 2.0 * math.pi\n        normal = (\n            math.sin(theta) * math.cos(phi),\n            math.cos(theta),\n            math.sin(theta) * math.sin(phi),\n        )\n        ref = (0.0, 1.0, 0.0)\n        if abs(sum(a * b for a, b in zip(normal, ref))) > 0.9:\n            ref = (1.0, 0.0, 0.0)\n        u = _normalize((\n            normal[1] * ref[2] - normal[2] * ref[1],\n            normal[2] * ref[0] - normal[0] * ref[2],\n            normal[0] * ref[1] - normal[1] * ref[0],\n        ))\n        v = (\n            normal[1] * u[2] - normal[2] * u[1],\n            normal[2] * u[0] - normal[0] * u[2],\n            normal[0] * u[1] - normal[1] * u[0],\n        )\n        for j in range(steps):\n            angle = 2.0 * math.pi * j / steps\n            point = (\n                u[0] * math.cos(angle) + v[0] * math.sin(angle),\n                u[1] * math.cos(angle) + v[1] * math.sin(angle),\n                u[2] * math.cos(angle) + v[2] * math.sin(angle),\n            )\n            out.append(Point3D(point[0] * radius, point[1] * radius, point[2] * radius))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_stream_on_torus(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    stream_count = max(1, int(geo.get(\"stream_N\", 0) or 0))\n    steps = max(8, int(geo.get(\"stream_steps\", 0) or 0))\n    R_major = float(geo.get(\"R_major\", 1.0) or 1.0)\n    r_minor = float(geo.get(\"r_minor\", 0.3) or 0.3)\n    out: List[Point3D] = []\n    for i in range(stream_count):\n        theta = (i / stream_count) * 2.0 * math.pi\n        phi = random.random() * 2.0 * math.pi\n        for j in range(steps):\n            theta += 0.08\n            phi += 0.12\n            ring = R_major + r_minor * math.cos(theta)\n            x = ring * math.cos(phi)\n            y = r_minor * math.sin(theta)\n            z = ring * math.sin(phi)\n            out.append(Point3D(x * radius, y * radius, z * radius))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_random_geometric_graph(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    nodes = _clamp_count(max(1, int(geo.get(\"rgg_nodes\", 0) or 0)), cap)\n    connect_radius = float(geo.get(\"rgg_radius\", 0.2) or 0.2) * radius\n    points = [\n        Point3D(\n            random.uniform(-radius, radius),\n            random.uniform(-radius, radius) * 0.3,\n            random.uniform(-radius, radius),\n        )\n        for _ in range(nodes)\n    ]\n    out = list(points)\n    for i, a in enumerate(points):\n        for j in range(i + 1, len(points)):\n            b = points[j]\n            dx = b.x - a.x\n            dy = b.y - a.y\n            dz = b.z - a.z\n            dist = math.sqrt(dx * dx + dy * dy + dz * dz)\n            if dist <= connect_radius and dist > 1e-6:\n                steps = 3\n                for s in range(1, steps):\n                    t = s / steps\n                    out.append(Point3D(a.x + dx * t, a.y + dy * t, a.z + dz * t))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_geodesic_sphere(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    level = max(0, int(geo.get(\"geo_level\", 0) or 0))\n    vertices, _faces = _subdivide_geodesic(level)\n    return _unique_points(vertices, radius, cap)\n\ndef _gen_geodesic(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    level = max(0, int(geo.get(\"geo_level\", 0) or 0))\n    vertices, faces = _subdivide_geodesic(level)\n    vectors: List[Tuple[float, float, float]] = list(vertices)\n    for a, b, c in faces:\n        va, vb, vc = vertices[a], vertices[b], vertices[c]\n        vectors.extend([_mix(va, vb, 0.5), _mix(vb, vc, 0.5), _mix(vc, va, 0.5)])\n    return _unique_points(vectors, radius, cap)\n\ndef _gen_geodesic_graph(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    level = max(0, int(geo.get(\"geo_graph_level\", 0) or 0))\n    vertices, faces = _subdivide_geodesic(level)\n    vectors: List[Tuple[float, float, float]] = []\n    edges = set()\n    for face in faces:\n        for i in range(3):\n            edge = tuple(sorted((face[i], face[(i + 1) % 3])))\n            edges.add(edge)\n    for a, b in edges:\n        va, vb = vertices[a], vertices[b]\n        vectors.append(va)\n        vectors.append(vb)\n        vectors.append(_mix(va, vb, 0.5))\n    return _unique_points(vectors, radius, cap)\n\ndef _gen_polyhedron_base(name: str, geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    layers = max(1, int(geo.get(\"poly_layers\", 0) or 0))\n    link_steps = max(0, int(geo.get(\"poly_link_steps\", 0) or 0))\n    vertices, faces = _polyhedron_vectors(name)\n    return _polyhedron_points(vertices, faces, radius, layers, link_steps, cap)\n\ndef _gen_tetrahedron(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    return _gen_polyhedron_base(\"tetrahedron\", geo, cap)\n\ndef _gen_cube(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    return _gen_polyhedron_base(\"cube\", geo, cap)\n\ndef _gen_octahedron(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    return _gen_polyhedron_base(\"octahedron\", geo, cap)\n\ndef _gen_dodecahedron(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    return _gen_polyhedron_base(\"dodecahedron\", geo, cap)\n\ndef _gen_icosahedron(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    return _gen_polyhedron_base(\"icosahedron\", geo, cap)\n\ndef _gen_polyhedron(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    layers = max(1, int(geo.get(\"poly_layers\", 0) or 0))\n    link_steps = max(0, int(geo.get(\"poly_link_steps\", 0) or 0))\n    vertices, faces = _parse_polyhedron_json(geo.get(\"polyhedron_data\"))\n    if not vertices:\n        vertices, faces = _polyhedron_vectors(\"cube\")\n    return _polyhedron_points(vertices, faces, radius, layers, link_steps, cap)\n\ndef _gen_truncated_icosa(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    ratio = clamp(float(geo.get(\"trunc_ratio\", 0.333) or 0.333), 0.05, 0.45)\n    base_vertices, faces = _polyhedron_vectors(\"icosahedron\")\n    vectors: List[Tuple[float, float, float]] = []\n    for face in faces:\n        pts = [base_vertices[idx] for idx in face[:3]]\n        cx = sum(p[0] for p in pts) / 3.0\n        cy = sum(p[1] for p in pts) / 3.0\n        cz = sum(p[2] for p in pts) / 3.0\n        for idx in face[:3]:\n            v = base_vertices[idx]\n            vectors.append(_mix(v, (cx, cy, cz), ratio))\n    layers = max(1, int(geo.get(\"poly_layers\", 0) or 0))\n    link_steps = max(0, int(geo.get(\"poly_link_steps\", 0) or 0))\n    return _polyhedron_points(vectors, [], radius, layers, link_steps, cap)\n\ndef _gen_stellated_icosa(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    scale = float(geo.get(\"stellated_scale\", 1.4) or 1.4)\n    base_vertices, faces = _polyhedron_vectors(\"icosahedron\")\n    vectors: List[Tuple[float, float, float]] = list(base_vertices)\n    for face in faces:\n        pts = [base_vertices[idx] for idx in face[:3]]\n        center = _normalize((\n            sum(p[0] for p in pts) / 3.0,\n            sum(p[1] for p in pts) / 3.0,\n            sum(p[2] for p in pts) / 3.0,\n        ))\n        vectors.append(_scale(center, scale))\n    layers = max(1, int(geo.get(\"poly_layers\", 0) or 0))\n    link_steps = max(0, int(geo.get(\"poly_link_steps\", 0) or 0))\n    return _polyhedron_points(vectors, [], radius, layers, link_steps, cap)\n\ndef _gen_blob(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    amp = float(geo.get(\"blob_noise_amp\", 0.2) or 0.2)\n    scale = float(geo.get(\"blob_noise_scale\", 1.0) or 1.0)\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / (lat_steps - 1 if lat_steps > 1 else 1)\n        theta = v * math.pi\n        sin_theta = math.sin(theta)\n        cos_theta = math.cos(theta)\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi\n            nx = sin_theta * math.cos(phi)\n            ny = cos_theta\n            nz = sin_theta * math.sin(phi)\n            n = _value_noise3(nx * scale, ny * scale, nz * scale)\n            offset = 1.0 + amp * (n - 0.5)\n            out.append(Point3D(radius * nx * offset, radius * ny * offset, radius * nz * offset))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_gyroid(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    scale = float(geo.get(\"gyroid_scale\", 1.0) or 1.0)\n    thickness = float(geo.get(\"gyroid_thickness\", 0.05) or 0.05) * radius\n    c = float(geo.get(\"gyroid_c\", 0.0) or 0.0)\n\n    def func(x: float, y: float, z: float) -> float:\n        sx = scale * x\n        sy = scale * y\n        sz = scale * z\n        return (\n            math.sin(sx) * math.cos(sy)\n            + math.sin(sy) * math.cos(sz)\n            + math.sin(sz) * math.cos(sx)\n            - c\n        )\n\n    points = _sample_implicit_surface(count, radius, func, 0.0, thickness)\n    return points[:_clamp_count(len(points), cap)]\n\ndef _gen_schwarz_P(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    scale = float(geo.get(\"schwarz_scale\", 1.0) or 1.0)\n    iso = float(geo.get(\"schwarz_iso\", 0.0) or 0.0)\n    thickness = radius * 0.03\n\n    def func(x: float, y: float, z: float) -> float:\n        sx = scale * x\n        sy = scale * y\n        sz = scale * z\n        return math.cos(sx) + math.cos(sy) + math.cos(sz)\n\n    points = _sample_implicit_surface(count, radius, func, iso, thickness)\n    return points[:_clamp_count(len(points), cap)]\n\ndef _gen_schwarz_D(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    scale = float(geo.get(\"schwarz_scale\", 1.0) or 1.0)\n    iso = float(geo.get(\"schwarz_iso\", 0.0) or 0.0)\n    thickness = radius * 0.03\n\n    def func(x: float, y: float, z: float) -> float:\n        sx = scale * x\n        sy = scale * y\n        sz = scale * z\n        return (\n            math.sin(sx) * math.sin(sy) * math.sin(sz)\n            + math.sin(sx) * math.cos(sy) * math.cos(sz)\n            + math.cos(sx) * math.sin(sy) * math.cos(sz)\n            + math.cos(sx) * math.cos(sy) * math.sin(sz)\n        )\n\n    points = _sample_implicit_surface(count, radius, func, iso, thickness)\n    return points[:_clamp_count(len(points), cap)]\n\ndef _gen_heart_implicit(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0)) * float(geo.get(\"heart_scale\", 1.0) or 1.0)\n\n    def func(x: float, y: float, z: float) -> float:\n        x /= radius\n        y /= radius\n        z /= radius\n        return (\n            (x * x + (9.0 / 4.0) * y * y + z * z - 1.0) ** 3\n            - x * x * z * z * z\n            - (9.0 / 80.0) * y * y * z * z * z\n        )\n\n    points = _sample_implicit_surface(count, radius, func, 0.0, radius * 0.02)\n    return points[:_clamp_count(len(points), cap)]\n\ndef _eval_sdf(expr: str | None, x: float, y: float, z: float) -> float:\n    if not expr:\n        return 0.0\n\n    def sphere(r: float) -> float:\n        return math.sqrt(x * x + y * y + z * z) - r\n\n    def box(sx: float, sy: float, sz: float) -> float:\n        dx = abs(x) - sx\n        dy = abs(y) - sy\n        dz = abs(z) - sz\n        outside = math.sqrt(max(dx, 0.0) ** 2 + max(dy, 0.0) ** 2 + max(dz, 0.0) ** 2)\n        inside = min(max(dx, max(dy, dz)), 0.0)\n        return outside + inside\n\n    def torus(R: float, r: float) -> float:\n        q = math.sqrt(x * x + z * z) - R\n        return math.sqrt(q * q + y * y) - r\n\n    env = {\n        \"sphere\": sphere,\n        \"box\": box,\n        \"torus\": torus,\n        \"union\": lambda a, b: min(a, b),\n        \"inter\": lambda a, b: max(a, b),\n        \"sub\": lambda a, b: max(a, -b),\n        \"abs\": abs,\n        \"min\": min,\n        \"max\": max,\n        \"sqrt\": math.sqrt,\n        \"sin\": math.sin,\n        \"cos\": math.cos,\n    }\n    try:\n        return float(eval(expr, {\"__builtins__\": {}}, env))\n    except Exception:\n        return 0.0\n\n\ndef _gen_metaballs(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    centers = _parse_vector_list(geo.get(\"metaballs_centers\"))\n    radii = _parse_number_list(geo.get(\"metaballs_radii\"))\n    iso = float(geo.get(\"metaballs_iso\", 1.0) or 1.0)\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    if not centers:\n        centers = [(0.0, 0.0, 0.0)]\n    if not radii:\n        radii = [0.6]\n\n    def field_value(x: float, y: float, z: float) -> float:\n        total = 0.0\n        for idx, center in enumerate(centers):\n            rx = x - center[0]\n            ry = y - center[1]\n            rz = z - center[2]\n            r = radii[min(idx, len(radii) - 1)]\n            dist2 = rx * rx + ry * ry + rz * rz + 1e-6\n            total += (r * r) / dist2\n        return total\n\n    out: List[Point3D] = []\n    attempts = 0\n    max_attempts = max(1000, count * 60)\n    while len(out) < count and attempts < max_attempts:\n        attempts += 1\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n        z = random.uniform(-radius, radius)\n        val = field_value(x, y, z)\n        if abs(val - iso) <= iso * 0.15:\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_distance_field_shape(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    expr = geo.get(\"df_ops\")\n    count = _clamp_count(max(1, int(geo.get(\"N\", 0) or 0)), cap)\n    radius = float(geo.get(\"R\", 1.0))\n    out: List[Point3D] = []\n    attempts = 0\n    max_attempts = max(1000, count * 60)\n    while len(out) < count and attempts < max_attempts:\n        attempts += 1\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n        z = random.uniform(-radius, radius)\n        val = _eval_sdf(expr, x, y, z)\n        if abs(val) <= radius * 0.05:\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\ndef _gen_superformula_3D(geo: Mapping[str, float], cap: int) -> List[Point3D]:\n    radius = float(geo.get(\"R\", 1.0))\n    lat_steps = max(2, int(geo.get(\"lat\", 0) or 0))\n    lon_steps = max(3, int(geo.get(\"lon\", 0) or 0))\n    m1 = float(geo.get(\"sf3_m1\", 0.0) or 0.0)\n    m2 = float(geo.get(\"sf3_m2\", 0.0) or 0.0)\n    m3 = float(geo.get(\"sf3_m3\", 0.0) or 0.0)\n    n1 = float(geo.get(\"sf3_n1\", 0.5) or 0.5)\n    n2 = float(geo.get(\"sf3_n2\", 0.5) or 0.5)\n    n3 = float(geo.get(\"sf3_n3\", 0.5) or 0.5)\n    a = float(geo.get(\"sf3_a\", 1.0) or 1.0)\n    b = float(geo.get(\"sf3_b\", 1.0) or 1.0)\n    scale = float(geo.get(\"sf3_scale\", 1.0) or 1.0)\n\n    def super(theta: float, m: float) -> float:\n        return _superformula2d(theta, m, a, b, n1, n2, n3)\n\n    out: List[Point3D] = []\n    for i in range(lat_steps):\n        v = i / (lat_steps - 1 if lat_steps > 1 else 1)\n        theta = v * math.pi - math.pi / 2.0\n        r2 = super(theta, m2)\n        for j in range(lon_steps):\n            u = j / lon_steps\n            phi = u * 2.0 * math.pi - math.pi\n            r1 = super(phi, m1)\n            r3 = super(phi, m3)\n            x = scale * radius * r1 * r2 * math.cos(theta) * math.cos(phi)\n            y = scale * radius * r1 * r2 * math.sin(theta)\n            z = scale * radius * r3 * math.cos(theta) * math.sin(phi)\n            out.append(Point3D(x, y, z))\n    return out[:_clamp_count(len(out), cap)]\n\nBUILTIN_GENERATORS = {\n    \"uv_sphere\": _gen_uv_sphere,\n    \"fibo_sphere\": _gen_fibo_sphere,\n    \"vogel_sphere_spiral\": _gen_vogel_sphere_spiral,\n    \"superquadric\": _gen_superquadric,\n    \"superellipsoid\": _gen_superellipsoid,\n    \"half_sphere\": _gen_half_sphere,\n    \"noisy_sphere\": _gen_noisy_sphere,\n    \"spherical_harmonics\": _gen_spherical_harmonics,\n    \"weighted_sphere\": _gen_weighted_sphere,\n    \"disk_phyllo\": _gen_disk_phyllo,\n    \"disk_phyllotaxis\": _gen_disk_phyllo,\n    \"archimede_spiral\": _gen_archimede_spiral,\n    \"log_spiral\": _gen_log_spiral,\n    \"rose_curve\": _gen_rose_curve,\n    \"superformula_2d\": _gen_superformula_2d,\n    \"superformula_2D\": _gen_superformula_2d,\n    \"density_warp\": _gen_density_warp,\n    \"density_warp_disk\": _gen_density_warp,\n    \"poisson_disk\": _gen_poisson_disk,\n    \"lissajous_disk\": _gen_lissajous_disk,\n    \"torus\": _gen_torus,\n    \"double_torus\": _gen_double_torus,\n    \"horn_torus\": _gen_horn_torus,\n    \"spindle_torus\": _gen_spindle_torus,\n    \"torus_knot\": _gen_torus_knot,\n    \"strip_twist\": _gen_strip_twist,\n    \"klein_bottle\": _gen_klein_bottle,\n    \"mobius\": _gen_mobius,\n    \"concentric_rings\": _gen_concentric_rings,\n    \"hex_packing_plane\": _gen_hex_packing_plane,\n    \"voronoi_seeds\": _gen_voronoi_seeds,\n    \"helix\": _gen_helix,\n    \"viviani_curve\": _gen_viviani_curve,\n    \"lissajous3d\": _gen_lissajous3d,\n    \"lissajous3D\": _gen_lissajous3d,\n    \"line_integral_convolution_sphere\": _gen_line_integral_convolution_sphere,\n    \"stream_on_torus\": _gen_stream_on_torus,\n    \"random_geometric_graph\": _gen_random_geometric_graph,\n    \"geodesic_sphere\": _gen_geodesic_sphere,\n    \"geodesic\": _gen_geodesic,\n    \"geodesic_graph\": _gen_geodesic_graph,\n    \"tetrahedron\": _gen_tetrahedron,\n    \"cube\": _gen_cube,\n    \"octahedron\": _gen_octahedron,\n    \"dodecahedron\": _gen_dodecahedron,\n    \"icosahedron\": _gen_icosahedron,\n    \"polyhedron\": _gen_polyhedron,\n    \"truncated_icosa\": _gen_truncated_icosa,\n    \"stellated_icosa\": _gen_stellated_icosa,\n    \"blob\": _gen_blob,\n    \"gyroid\": _gen_gyroid,\n    \"schwarz_P\": _gen_schwarz_P,\n    \"schwarz_D\": _gen_schwarz_D,\n    \"heart_implicit\": _gen_heart_implicit,\n    \"metaballs\": _gen_metaballs,\n    \"distance_field_shape\": _gen_distance_field_shape,\n    \"superformula_3D\": _gen_superformula_3D,\n}\n\ndef _wrap_points(points):\n    out = []\n    for item in points:\n        if hasattr(item, \"x\") and hasattr(item, \"y\") and hasattr(item, \"z\"):\n            try:\n                out.append((float(item.x), float(item.y), float(item.z)))\n            except (TypeError, ValueError):\n                continue\n        elif isinstance(item, (list, tuple)) and len(item) >= 3:\n            try:\n                out.append((float(item[0]), float(item[1]), float(item[2])))\n            except (TypeError, ValueError):\n                continue\n    return out\n\ndef generate_density_warp_disk_geometry(params, N):\n    cap = int(N or 0)\n    points = BUILTIN_GENERATORS['density_warp_disk'](params, cap)\n    wrapped = _wrap_points(points)\n    return wrapped[:cap] if cap else wrapped\n"
  },
  "meta": {
    "category": "Plans et spirales",
    "label": "Disque densit pilote",
    "description": "Points rpartis sur un disque en appliquant une densit radiale personnalise.",
    "parameters": [
      "R",
      "N",
      "density_pdf"
    ]
  }
}
